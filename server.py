import asyncio
from asyncio import StreamReader, StreamWriter
import json
from protocol import Protocols
from gameLogic import GameLogic

'''
What do I need server_socket to do?
I need server to accept incoming connections 
Handle match making process
fetch and store data in db
Store instances of games and players in them as another process is initialising the game
'''
#Server setup
host = "localhost"
port = 80
games_dict = {}         #Key:pair → Game ID: game logic instance 
client_connected = {}   #Key:pair Game ID → set of connected clients 


            
async def handleClient(reader:StreamReader, writer: StreamWriter): #ConnectionResetError maybe raised do this in try block do avoid exceptions being raised 
    while True:
        try:
            
            data = await reader.read(100)
            if not data:
                break

            message = json.loads(data.decode())
            if message['gameID'] not in client_connected:
                client_connected[message['gameID']] = {writer}

            else:
                 client_connected[message['gameID']].add(writer)           
            match message['m_type']:
                case Protocols.Request.FOLD:
                    await foldClient(reader, writer, message['gameID'])
                case Protocols.Request.RAISE:
                    await raiseClient(reader, writer, message['gameID'])
                case Protocols.Request.CHECK:
                    await clientCheck(reader, writer, message['gameID'])
                case Protocols.Request.CALL:
                    await clientCall(reader, writer, message['gameID'])
                case Protocols.Request.LEAVE:
                    print("Client has disconnected: ")
                    break

        except ConnectionResetError as e:
            print(f"disconnected from {writer.get_extra_info('peername')}")
            writer.close()
            await writer.wait_closed()
        
        finally:    #This statement was generated by ChatGTP
            # Cleanup on disconnect
            if writer in client_connected.get(message['gameID'], set()):
                client_connected[message['gameID']].remove(writer)
            if not client_connected.get(message['gameID']):
                client_connected.pop(message['gameID'], None)
            writer.close()
            await writer.wait_closed()


    writer.close()
    await writer.wait_closed()


async def foldClient(reader:StreamReader, writer:StreamWriter, gameCode):
    print("player has folded")
    #GameLogic manipulation 
    game = games_dict[gameCode]
    #game.foldPlayer()
    #Fold player
    #Broadcast messages to all other players 
    for client_writer in client_connected[gameCode]:
        if client_writer != writer:
            try:
                client_writer.write(b"player has folded")
                await client_writer.drain()
            except ConnectionResetError:    #If a player has disconnected 
                print("client has disconnected during broadcast")
                client_connected[gameCode].remove(client_writer)


async def raiseClient(reader:StreamReader, writer:StreamWriter, gameCode):
    print("player has raise")
    #GameLogic manipulation 
    game = games_dict[gameCode]

    for client_writer in client_connected[gameCode]:
        if client_writer != writer:
            try:
                client_writer.write(b"player has raise the pot by __")
                await client_writer.drain()

            except ConnectionResetError:
                print("client has disconnected during broadcast")
                client_connected[gameCode].remove(client_writer)


async def clientCheck(reader, writer, gameCode):
    print("player has raise")
    #GameLogic manipulation 
    game = games_dict[gameCode]

    for client_writer in client_connected[gameCode]:
        if client_writer != writer:
            try:
                client_writer.write(b"player has checked")
                await client_writer.drain()

            except ConnectionResetError:
                print("client has disconnected during broadcast")
                client_connected[gameCode].remove(client_writer)

async def clientCall(reader:StreamReader, writer:StreamWriter, gameCode):
    print("player has raise")
    #GameLogic manipulation 
    game = games_dict[gameCode]

    for client_writer in client_connected[gameCode]:
        if client_writer != writer:
            try:
                client_writer.write(b"player has called")
                await client_writer.drain()

            except ConnectionResetError:
                print("client has disconnected during broadcast")
                client_connected[gameCode].remove(client_writer)

    

    

async def main():
    server_socket = await asyncio.start_server(handleClient, host, port)
    
    addr = server_socket.sockets[0].getsockname()
    print(f"serving on {addr}")

    async with server_socket:
        await server_socket.serve_forever()

if __name__ == "__main__":
    try:
        #Need to use tasks or TaskGroups to utilise concurrency 
        asyncio.run(main())
        print("event_loop ended")

    except KeyboardInterrupt:
        print("We are ending test")

