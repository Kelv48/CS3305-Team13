import asyncio
import websockets
import json
import logging
import websockets.asyncio
from websockets.asyncio.server import serve
import websockets.asyncio.server
from src.network.server.protocol import Protocols


#This is a demo for what the game server process will look like

'''
What do I need server_socket to do?
I need server to accept incoming connections 
Handle match making process
fetch and store data in db
Store instances of games and players in them as another process is initialising the game
'''
#Server setup
host = "localhost"
port = 80
games_dict = {}         #Key:pair → Game ID: game logic instance 
client_connected = {}   #Key:pair Game ID → set of connected clients 


async def handleClient(websocket: websockets.asyncio.server.ServerConnection, path): #ConnectionResetError maybe raised do this in try block do avoid exceptions being raised 
    logging.debug("handling client has started")
    print(f"Connection from {websocket.remote_address}")
    print(f"Path of client: {path}")
    while True:
        try:
            data = await websocket.recv(100)
            if not data:
                break

            message = json.loads(data.decode())

            #The following if statements will be subject to changed when redis is implemented 
            if message['gameID'] not in client_connected:
                client_connected[message['gameID']] = {websocket}
                print(f"added client to list\n {client_connected}")

            else:
                 client_connected[message['gameID']].add(websocket)       

            if message['gameID'] not in games_dict:
                #Create a new instance of a game and store in game_dict
                pass

            print(f"message data: {message}")
            print("checking message")
            match message['m_type']:
                case Protocols.Request.FOLD:
                    await foldClient(websocket, message['gameID'])
                case Protocols.Request.RAISE:
                    await raiseClient(websocket, message['gameID'])
                case Protocols.Request.CHECK:
                    await clientCheck(websocket, message['gameID'])
                case Protocols.Request.CALL:
                    await clientCall(websocket, message['gameID'])
                case Protocols.Request.LEAVE:
                    await websocket.send("Client has left".encode())
                    print("Client has disconnected: ")
                    break
        except ConnectionResetError as e:
            print(f"disconnected from {websocket.remote_address}")
           
            if message != None:  #If there is no message then can't check what game client belongs to

                #This statement was partially generated by ChatGTP
                if websocket in client_connected.get(message['gameID'], set()):
                    client_connected[message['gameID']].remove(websocket)
                
                if not client_connected.get(message['gameID']):
                    client_connected.pop(message['gameID'], None)
            
            break
        
    #Disconnects the client 
    print("client is closed")
    await websocket.wait_closed()
    logging.debug("finished client handling")


async def foldClient(websocket, gameCode):
    print("player has folded")
    #GameLogic manipulation 
    #game = games_dict[gameCode]
    #game.foldPlayer()
    
    #Broadcast messages to all other players 
    for client_writer in client_connected[gameCode]:
        #if client_writer != websocket:
            try:
                await client_writer.send("player has folded".encode())
            except ConnectionResetError:    #If a player has disconnected 
                print("client has disconnected during broadcast")
                client_connected[gameCode].remove(client_writer)
    
    print("end of function")


async def raiseClient(websocket, gameCode):
    print("player has raise")
    #GameLogic manipulation 
    #game = games_dict[gameCode]

    for client_writer in client_connected[gameCode]:
        #if client_writer != websocket:
            try:
                await client_writer.send("player has raise the pot by __".encode())
            

            except ConnectionResetError:
                print("client has disconnected during broadcast")
                client_connected[gameCode].remove(client_writer)
    print("end of function")


async def clientCheck(websocket, gameCode):
    print("player has checked")
    #GameLogic manipulation 
    #game = games_dict[gameCode]

    for client_writer in client_connected[gameCode]:
        #if client_writer != websocket:
            try:
                await client_writer.send("player has checked".encode())
        
            except ConnectionResetError:
                print("client has disconnected during broadcast")
                client_connected[gameCode].remove(client_writer)

    print("end of function")

async def clientCall(websocket, gameCode):
    print("player has called")
    #GameLogic manipulation 
    #game = games_dict[gameCode]

    for client_writer in client_connected[gameCode]:
        #if client_writer != websocket:
            try:
                await client_writer.send("player has called".encode())

            except ConnectionResetError:
                print("client has disconnected during broadcast")
                client_connected[gameCode].remove(client_writer)
    print("end of function")

    
async def main():
    print("starting server")
    async with serve(handleClient, host, port) as server:
        await server.serve_forever()
    

if __name__ == "__main__":
    try:
        #Need to use tasks or TaskGroups to utilise concurrency 
        asyncio.run(main())
        print("event_loop ended")

    except KeyboardInterrupt:
        print("We are ending test")

