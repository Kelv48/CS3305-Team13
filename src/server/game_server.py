import asyncio
import json
import logging
from string import Template
from network.server.protocol import Protocols
from websockets.exceptions import ConnectionClosedError
from websockets.asyncio.server import serve, ServerConnection


#This is a demo for what the game server process will look like

'''
What do I need server_socket to do?
I need server to accept incoming connections 
Handle match making process
fetch and store data in db
Store instances of games and players in them as another process is initialising the game
'''
#Server setup
host = "localhost"
port = 443
activeSessions = {}     #Key:pair Game ID â†’ set of connected clients 
template = Template('{"m_type": "$m_type", "data": "$data"}')   #This is a template for message to be sent to clients

#Configure logging 
logging.basicConfig(level=logging.DEBUG, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

#TODO:Integrate Redis to server to extract any updates in the server published by match_making.py

async def handleClient(websocket: ServerConnection): #ConnectionClosedError maybe raised do this in try block do avoid exceptions being raised
    #TODO:When a client connects for the first time send them the game instance associate with their sessionID
    logger.info(f"Connection from {websocket.remote_address}")
    while True:
        try:
            logger.info(f"Received message from client: {websocket.remote_address}")
            data = await websocket.recv(100)
            if not data:
                logger.error(f"Faulty/Missing message from client {websocket.remote_address}")
                break

            message = json.loads(data.decode())
            logger.debug(f"Received: {message}")

            activeSessions[message['sessionID']].add(websocket)       

            match message['m_type']:
                case Protocols.Request.FOLD:
                    logger.info(f"client is folding")
                    await foldClient(websocket, message['sessionID'])
                case Protocols.Request.RAISE:
                    await raiseClient(websocket, message['sessionID'])
                case Protocols.Request.CHECK:
                    await clientCheck(websocket, message['sessionID'])
                case Protocols.Request.CALL:
                    await clientCall(websocket, message['sessionID'])
                case Protocols.Request.LEAVE:
                    await websocket.send("Client has left".encode())
                    print("Client has disconnected: ")
                    break
        except ConnectionResetError as e:
            print(f"disconnected from {websocket.remote_address}")

        except KeyError as e:
            error_message = template.substitute(m_type=Protocols.Response.ERROR, data='Invalid session ID')
            await websocket.send(error_message.encode())

        except ConnectionClosedError as e:
            print(f"disconnected from {websocket.remote_address}")
           
            if message != None:  #If there is no message then can't check what game client belongs to

                #This statement was partially generated by ChatGTP
                if websocket in activeSessions.get(message['sessionID'], set()):    #Removes websocket from set
                    activeSessions[message['sessionID']].discard(websocket)
                
                if not activeSessions.get(message['sessionID']):    #Deletes session if no WebSockets are left
                    activeSessions.pop(message['sessionID'], None)
            
            break
        
    #Disconnects the client 
    print("client is closed")
    await websocket.close()
    logging.debug("finished client handling")


async def foldClient(websocket: ServerConnection, sessionID):
    print("player has folded")
    #GameLogic manipulation 
    #game = games_dict[sessionID]
    #game.foldPlayer()
    
    #Broadcast messages to all other players 
    logger.debug("starting to broadcast message")
    for client_writer in activeSessions[sessionID]:
        #if client_writer != websocket:
            try:
                await client_writer.send("player has folded".encode())

            except ConnectionClosedError:    #If a player has disconnected 
                print("client has disconnected during broadcast")
                activeSessions[sessionID].remove(client_writer)
    
    print("end of function")


async def raiseClient(websocket: ServerConnection, sessionID):
    print("player has raise")
    #GameLogic manipulation 
    #game = games_dict[sessionID]

    logger.debug("starting to broadcast message")
    for client_writer in activeSessions[sessionID]:
        #if client_writer != websocket:
            try:
                await client_writer.send("player has raise the pot by __".encode())

            except ConnectionClosedError:
                print("client has disconnected during broadcast")
                activeSessions[sessionID].remove(client_writer)
    print("end of function")


async def clientCheck(websocket: ServerConnection, sessionID):
    print("player has checked")
    #GameLogic manipulation 
    #game = games_dict[sessionID]

    logger.debug("starting to broadcast message")
    for client_writer in activeSessions[sessionID]:
        #if client_writer != websocket:
            try:
                await client_writer.send("player has checked".encode())
        
            except ConnectionClosedError:
                print("client has disconnected during broadcast")
                activeSessions[sessionID].remove(client_writer)

    print("end of function")

async def clientCall(websocket: ServerConnection, sessionID):
    print("player has called")
    #GameLogic manipulation 
    #game = games_dict[sessionID]

    logger.debug("starting to broadcast message")
    for client_writer in activeSessions[sessionID]:
        #if client_writer != websocket:
            try:
                await client_writer.send("player has called".encode())

            except ConnectionClosedError:
                print("client has disconnected during broadcast")
                activeSessions[sessionID].remove(client_writer)
    print("end of function")

    
async def main():
    logger.info("server has started")
    async with serve(handleClient, host, port) as server:
        await server.serve_forever()
    

if __name__ == "__main__":
    try:
        #Need to use tasks or TaskGroups to utilise concurrency 
        asyncio.get_event_loop().set_debug(True)
        asyncio.run(main())
        print("event_loop ended")

    except KeyboardInterrupt:
        print("We are ending test")

